import { techError, type TechError } from '{{basicErrorTypesFrom}}';
import { getLogger } from '@logtape/logtape';
import { AsyncResult, Err, None, Ok, Some } from 'ts-results-es';
import { Service } from 'electrodb';

import {
    create{{aggregateName}},
    {{aggregateName}},
    {{aggregateName}}Data,
    {{aggregateName}}Timestamps,
} from '../../domainmodel/{{aggregateName}}.js';
import { {{repositoryName}} } from '../../domainmodel/{{repositoryName}}.js';

import { configure{{aggregateName}}Entity } from './{{aggregateName}}Entity.js';

type TransactionOnRepoProvider<RepositoryType> = <T, E>(
    work: (trx: RepositoryType) => AsyncResult<T, E>,
) => AsyncResult<T, E>;

type DynamoDBTransaction = {
  writeOps: ((entities: any) => any)[];
};

/**
 * Implements the {{repositoryName}} interface, as an adapter to AWS DynamoDB.
 * @param singleDBTableName name of the database table (single DB table pattern)
 */
export const {{repositoryName}}Impl = (
    singleDBTableName: string,
): TransactionOnRepoProvider<{{repositoryName}}> => {
    const entity = configure{{aggregateName}}Entity(singleDBTableName);
    const service = new Service({ {{aggregateName}}: entity });
    const logger = getLogger(['YOUR_APP_NAME', 'MODULE_NAME']);

    const dataOf = ({
        createdAt,
        updatedAt,
        ...rest
    }: {{aggregateName}}Data & {{aggregateName}}Timestamps): {{aggregateName}}Data => rest;

    const timestampsOf = ({
        createdAt,
        updatedAt,
    }: {{aggregateName}}Data & {{aggregateName}}Timestamps): {{aggregateName}}Timestamps => ({
        createdAt,
        updatedAt,
    });

    const withTransactionFor =
        <R>(createRepository: (trx: DynamoDBTransaction) => R): TransactionOnRepoProvider<R> =>
        (work) => {
            const writeOps: any[] = [];
            const trx = { writeOps };
            const repo = createRepository(trx);

            return work(repo).andThen((result) => {
                return trx.writeOps.length === 0
                    ? Ok(result)
                    : // Execute batched writes
                      new AsyncResult(
                          service.transaction
                              .write(({ {{aggregateName}} }) => trx.writeOps.map(op => op({ {{aggregateName}} })))
                              .go()
                              .then(() => Ok(result))
                              .catch((error: Error) => {
                                  const method = '{{repositoryName}}.withTransactionFor()';
                                  logger.error(`{ method } failed:\n { error }`, {
                                      method,
                                      error,
                                  });
                                  return Err(techError(`${method} failed: ${error.message}`));
                              }),
                      );
            });
        };

    return withTransactionFor<{{repositoryName}}>((trx) => ({
        {{#each methods}}
        {{name}}({ {{formattedParameterNames}} }) {
            return new AsyncResult(Err(techError('Method {{name}} not implemented')));
        },

        {{/each}}

        add({ item }) {
            trx.writeOps.push((entities) => entities.{{aggregateName}}.put(item).commit({ response: "all_old" }));
            return new AsyncResult(Ok.EMPTY);
        },

        get({ id }) {
            return new AsyncResult(
                entity.get({ id }).go()
                    .then(({ data }) =>
                        Ok(data ? Some(create{{aggregateName}}(dataOf(data), timestampsOf(data))) : None)
                    )
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.get()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id,
                        });
                        return Err(techError(`${method} failed for ID ${id}: ${error.message}`));
                    }),
            );
        },

        update({ id, updates }) {
            trx.writeOps.push((entities) => entities.{{aggregateName}}.update({ id }).set(updates).commit({ response: "all_new" }));
            return new AsyncResult(Ok.EMPTY);
        },

        remove({ item }) {
            trx.writeOps.push((entities) => entities.{{aggregateName}}.delete({ id: item.id }).commit({ response: "all_old" }));
            return new AsyncResult(Ok.EMPTY);
        },
    }));
};
