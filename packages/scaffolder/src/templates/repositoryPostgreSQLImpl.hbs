import { Kysely, Transaction } from 'kysely';
import { AsyncResult, Err, None, Ok, Some } from 'ts-results-es';

import { techError } from '{{basicErrorTypesFrom}}';
import { getLogger } from '@logtape/logtape';

import {
    create{{aggregateName}},
    {{aggregateName}}Data,
    {{aggregateName}}Timestamps,
} from '../../domain/{{aggregateName}}.js';
import { {{repositoryName}} } from '../../domain/{{repositoryName}}.js';

import { Database } from './{{aggregateName}}Types.js';

type TransactionOnRepoProvider<RepositoryType> = <T, E>(
    work: (trx: RepositoryType) => AsyncResult<T, E>,
) => AsyncResult<T, E>;

export const {{repositoryName}}Impl = (
    db: Kysely<Database>,
): TransactionOnRepoProvider<{{repositoryName}}> => {
    const logger = getLogger(['YOUR_APP_NAME', 'MODULE_NAME']);

    // `withTransactionFor` lives inside the factory so it closes over `db`.
    const withTransactionFor =
        <R>(createRepository: (trx: Transaction<Database>) => R): TransactionOnRepoProvider<R> =>
        (work) =>
            new AsyncResult(db.transaction().execute((trx) => work(createRepository(trx)).promise));

    const dataOf = ({
        createdAt,
        updatedAt,
        ...rest
    }: SelectedFrom{{aggregateName}}Table): {{aggregateName}}Data => rest as {{aggregateName}}Data;

    const timestampsOf = ({
        createdAt,
        updatedAt,
    }: SelectedFrom{{aggregateName}}Table): {{aggregateName}}Timestamps => ({
        createdAt,
        updatedAt,
    });

    return withTransactionFor<{{repositoryName}}>((trx) => ({
        {{#each methods}}
        {{name}}({ {{formattedParameterNames}} }) {
            return new AsyncResult(Err(techError('Method {{name}} not implemented')));
        },

        {{/each}}

        add({ item }) {
            return new AsyncResult(
                trx
                    .insertInto('{{tableName}}')
                    .values(item)
                    .execute()
                    .then(() => Ok.EMPTY)
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.add()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            item,
                        });
                        return Err(techError(`${method} failed for ID ${item.id}: ${error.message}`));
                    }),
            );
        },

        get({ id }) {
            return new AsyncResult(
                trx
                    .selectFrom('{{tableName}}')
                    .selectAll()
                    .where('id', '=', id)
                    .executeTakeFirst()
                    .then((result) =>
                        Ok(
                            result
                                ? Some(create{{aggregateName}}(dataOf(result), timestampsOf(result)))
                                : None,
                        ),
                    )
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.get()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id,
                        });
                        return Err(techError(`${method} failed for ID ${id}: ${error.message}`));
                    }),
            );
        },

        update({ id, updates }) {
            return new AsyncResult(
                trx
                    .updateTable('{{tableName}}')
                    .set(updates)
                    .where('id', '=', id)
                    .execute()
                    .then(() => Ok.EMPTY)
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.update()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id,
                            updates,
                        });
                        return Err(techError(`${method} failed for ID ${id}: ${error.message}`));
                    }),
            );
        },

        remove({ item }) {
            return new AsyncResult(
                trx
                    .deleteFrom('{{tableName}}')
                    .where('id', '=', item.id)
                    .execute()
                    .then(() => Ok.EMPTY)
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.remove()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id: item.id,
                        });
                        return Err(techError(`${method} failed for ID ${item.id}: ${error.message}`));
                    }),
            );
        },
    }));
};
