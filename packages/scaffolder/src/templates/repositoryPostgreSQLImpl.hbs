import { Kysely } from 'kysely';
import { AsyncResult, Err, None, Ok, Some } from 'ts-results-es';

import { techError, type WithUnitOfWork, withUnitOfWork } from '{{basicErrorTypesFrom}}';
import { getLogger } from '@logtape/logtape';

import {
    create{{aggregateName}},
    type {{aggregateName}}Data,
    type {{aggregateName}}Timestamps,
} from '../../domain/{{aggregatePackageName}}/{{aggregateName}}.js';
import { type {{repositoryName}} } from '../../domain/{{aggregatePackageName}}/{{repositoryName}}.js';

import { type Database, type SelectedFrom{{aggregateName}}Table } from './{{aggregateName}}Types.js';

export const {{repositoryName}}Impl = (db: Kysely<Database>): WithUnitOfWork<{{repositoryName}}> => {
    const logger = getLogger(['{{boundedContext}}', '{{aggregatePackageName}}', 'persistence']);

    const dataOf = ({ createdAt, updatedAt, ...rest }: SelectedFrom{{aggregateName}}Table): {{aggregateName}}Data =>
        rest as {{aggregateName}}Data;

    const timestampsOf = ({ createdAt, updatedAt }: SelectedFrom{{aggregateName}}Table): {{aggregateName}}Timestamps => ({
        createdAt,
        updatedAt,
    });

    // strips the functions from an object because Kysely would otherwise call them!
    const withoutFunctions = <T extends object>(obj: T) =>
        Object.fromEntries(Object.entries(obj).filter(([, v]) => typeof v !== 'function')) as {
            [K in keyof T as T[K] extends Function ? never : K]: T[K];
        };

    async function createKyselyTransaction() {
        return db
            .startTransaction()
            .execute()
            .then((trx) => ({
                commit: () => trx.commit().execute(),
                rollback: () => trx.rollback().execute(),
                kyselyTrx: trx,
            }));
    }

    return withUnitOfWork(createKyselyTransaction, (trx) => ({
        {{#each methods}}
        {{name}}({ {{formattedParameterNames}} }) {
            return new AsyncResult(Err(techError('Method {{name}} not implemented')));
        },

        {{/each}}

        add({ item }) {
            return new AsyncResult(
                trx.kyselyTrx
                    .insertInto('{{tableName}}')
                    .values(withoutFunctions(item))
                    .execute()
                    .then(() => Ok.EMPTY)
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.add()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            item,
                        });
                        return Err(
                            techError(`${method} failed for ID ${item.id}: ${error.message}`),
                        );
                    }),
            );
        },

        get({ id }) {
            return new AsyncResult(
                trx.kyselyTrx
                    .selectFrom('{{tableName}}')
                    .selectAll()
                    .where('id', '=', id)
                    .executeTakeFirst()
                    .then((result) =>
                        Ok(
                            result
                                ? Some(create{{aggregateName}}(dataOf(result), timestampsOf(result)))
                                : None,
                        ),
                    )
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.get()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id,
                        });
                        return Err(techError(`${method} failed for ID ${id}: ${error.message}`));
                    }),
            );
        },

        update({ id, updates }) {
            return new AsyncResult(
                trx.kyselyTrx
                    .updateTable('{{tableName}}')
                    .set(withoutFunctions(updates))
                    .where('id', '=', id)
                    .execute()
                    .then(() => Ok.EMPTY)
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.update()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id,
                            updates,
                        });
                        return Err(techError(`${method} failed for ID ${id}: ${error.message}`));
                    }),
            );
        },

        remove({ item }) {
            return new AsyncResult(
                trx.kyselyTrx
                    .deleteFrom('{{tableName}}')
                    .where('id', '=', item.id)
                    .execute()
                    .then(() => Ok.EMPTY)
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.remove()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id: item.id,
                        });
                        return Err(
                            techError(`${method} failed for ID ${item.id}: ${error.message}`),
                        );
                    }),
            );
        },
    }));
};
