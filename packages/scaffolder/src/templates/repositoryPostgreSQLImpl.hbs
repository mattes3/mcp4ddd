import { Knex } from 'knex';
import { Model, Transaction } from 'objection';
import { AsyncResult, Err, None, Ok, Some } from 'ts-results-es';

import { techError } from '@ddd-components/runtime';
import { getLogger } from '@logtape/logtape';

// Using .js extensions for ESM compliance with TypeScript's nodenext moduleResolution
import {
    create{{aggregateName}},
    {{aggregateName}}Data,
    {{aggregateName}}Timestamps,
} from '../../domainmodel/{{aggregateName}}.js';
import { {{repositoryName}} } from '../../domainmodel/{{repositoryName}}.js';

import { {{aggregateName}}Model } from './{{aggregateName}}Model.js';

type TransactionOnRepoProvider<RepositoryType> = <T>(
    work: (trx: RepositoryType) => Promise<T>,
) => Promise<T>;

const withTransactionFor =
    <R>(createRepository: (trx: Transaction) => R): TransactionOnRepoProvider<R> =>
    async (work) =>
        Model.transaction(async (trx) => work(createRepository(trx)));

export const {{repositoryName}}Impl = (
    knex: Knex,
): TransactionOnRepoProvider<{{repositoryName}}> => {
    // Initialize knex for Objection models
    {{aggregateName}}Model.knex(knex);

    const logger = getLogger(['YOUR_APP_NAME', 'MODULE_NAME']);

    const dataOf = ({
        createdAt,
        updatedAt,
        ...rest
    }: {{aggregateName}}Data & {{aggregateName}}Timestamps): {{aggregateName}}Data => rest;

    const timestampsOf = ({
        createdAt,
        updatedAt,
    }: {{aggregateName}}Data & {{aggregateName}}Timestamps): {{aggregateName}}Timestamps => ({
        createdAt,
        updatedAt,
    });

    return withTransactionFor<{{repositoryName}}>((trx) => ({
        {{#each methods}}
        {{name}}({ {{formattedParameterNames}} }) {
            return new AsyncResult(Err(techError('Method {{name}} not implemented')));
        },

        {{/each}}

        add({ item }) {
            return new AsyncResult(
                {{aggregateName}}Model.query(trx)
                    .insert(item)
                    .then(() => Ok(undefined))
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.add()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            item,
                        });
                        return Err(techError(`${method} failed for ID ${item.id}: ${error.message}`));
                    }),
            );
        },

        get({ id }) {
            return new AsyncResult(
                {{aggregateName}}Model.query(trx)
                    .findById(id)
                    .then((result) =>
                        Ok(
                            result
                                ? Some(create{{aggregateName}}(dataOf(result), timestampsOf(result)))
                                : None,
                        ),
                    )
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.get()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id,
                        });
                        return Err(techError(`${method} failed for ID ${id}: ${error.message}`));
                    }),
            );
        },

        update({ id, updates }) {
            return new AsyncResult(
                {{aggregateName}}Model.query(trx)
                    .patchAndFetchById(id, updates)
                    .then((result) =>
                        Ok(create{{aggregateName}}(dataOf(result), timestampsOf(result))),
                    )
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.update()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id,
                            updates,
                        });
                        return Err(techError(`${method} failed for ID ${id}: ${error.message}`));
                    }),
            );
        },

        remove({ item }) {
            return new AsyncResult(
                {{aggregateName}}Model.query(trx)
                    .deleteById(item.id)
                    .then(() => Ok(undefined))
                    .catch((error: Error) => {
                        const method = '{{repositoryName}}.remove()';
                        logger.error(`{ method } failed:\n { error }`, {
                            method,
                            error,
                            id: item.id,
                        });
                        return Err(techError(`${method} failed for ID ${item.id}: ${error.message}`));
                    }),
            );
        },
    }));
};
