import { AsyncResult, type Result, Ok, Err } from 'ts-results-es';

import { techError } from '{{basicErrorTypesFrom}}';

// Using .js extensions for ESM compliance with TypeScript's nodenext moduleResolution
import { type {{serviceParametersType}} } from './{{serviceParametersType}}.js';
import { type {{serviceErrorType}}, create{{serviceErrorType}} } from './create{{serviceErrorType}}s.js';

export type {{serviceType}} = (params: {{serviceParametersType}}) => {{{asyncResultType}}};

// @DomainService
export const {{serviceName}}Impl =
    ({{formattedInjectedDependencies}}): {{serviceType}} =>
    ({ {{formattedParameterNames}} }) => {
        return new AsyncResult(domainLogic().catch((e: Error) => Err(techError(e.message))));
        async function domainLogic(): {{{promiseOfResultType}}} {
            //human dev: implement this domain logic here and return a {{{wrappedResultType}}} as in Rust.
            //human dev: No try-catch inside here â€“ return Ok() or Ok(value) or Err(create{{serviceErrorType}}(explanation)), instead.
            //human dev: Avoid await, return the promise itself, instead!
        }
    };
