import { AsyncResult, type Result, Ok, Err } from 'ts-results-es';

import { beginWith, safeAsync } from '{{basicTypesFrom}}';
import { techError, type TechError } from '{{basicErrorTypesFrom}}';

// Using .js extensions for ESM compliance with TypeScript's nodenext moduleResolution
import { type {{serviceParametersType}} } from './{{serviceParametersType}}.js';
import { type {{serviceErrorType}}, create{{serviceErrorType}} } from './create{{serviceErrorType}}s.js';

export type {{serviceType}} = (params: {{serviceParametersType}}) => {{{asyncResultType}}};

// @DomainService
export const {{serviceName}}Impl =
    ({{formattedInjectedDependencies}}): {{serviceType}} =>
    (parameterObject) => {
        return beginWith(parameterObject)
            .andThen((params) => 
                Ok(undefined)
                //human dev: implement this domain logic here and return a {{{asyncResultType}}} as in Rust.
                //human dev: No try-catch inside here â€“ return Ok() or Ok(value) or Err(create{{serviceErrorType}}(explanation)), instead.
                //human dev: Avoid await, return the promise itself, instead!
            );
    };
